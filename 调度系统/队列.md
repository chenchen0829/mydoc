## 队列属性

```
1. 最小令牌数
2. 最大令牌数
3. 权重
```



## 队列划分

```
1. kpi队列
2. 低延迟队列(临时任务队列)
3. 高优先级队列
4. 中等优先级队列(普通优先级队列)
5. 默认队列(低优先级队列, 重刷队列)
```



## 队列权重划分

```
权重划分根据实际使用场景。
1：kpi队列优先级最高， 一般权重最高。 低延迟任务一般为临时task和高优先级的优先级可以高一点。至于谁高一点比较好，我比较倾向于低延迟任务。
2. 其他的队列优先级可以根据高中低依次降低。
3. 重刷任务的优先级最低。
```



## 队列最小令牌数

```
1：kpi队列默认最小令牌数应该占据总令牌数的一半以上。
2: 低延迟队列，临时任务应该根据每天任务量的多少划分最小队列。
3. 其他队列的最小令牌数为0
```



## 分配算法

```
max-min fairness算法(最大最小公平算法)
1. 资源按照需求递增的顺序进行分配，通过权重来标准化。
2. 不存在用户得到的资源超过自己的需求。
3. 未得到满足的用户按照权重分享资源。
算法描述(1. 获取可以分配的所有份额，2. 找到一个最小刚好满足所有权重对应的资源大于等于可分配的所有资源， 3. 根据这个权重值，通过二分查找法，找到一个精确的权重，刚好接近分配所有的资源。)
```



## 队列优先级

```
1：当前执行数+等待数 < 最大最小公平分片数，并且权重高的优先调度。
   如果执行数都小于最小分片数，谁的队列空闲越多，谁优先调度。       
1. 根据最小份额，当前使用量，当前buffer中的任务数，权重来划分优先级。
2. 当前使用量小于最小份额，优先调度，如果都小于根据空闲份额的比例优先调度。
3. 当前使用大于最小份额，根据单位权重使用量小的优先级调度。

临界点
最大最小公平分片数。这个根据上面的算法得到


每次分配队列必然会分配给一个queue。先根据最小份额进行分配，没有加入抢占的功能，而是保证了突发情况，都可以进行资源的充分利用。抢占还是采用人工kill的方式。
```



## 任务分配

```
1：符合条件的task插入到各自队列的buffer中。
2：根据队列的优先级性排序
3：从排序好的队列中依次迭代(周期为1s，可以根据任务数减小周期)，取出符合条件的task，每一次仅取出一个task。

```

